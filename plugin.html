<!-- 1. Popper v2 UMD build -->
<script src="https://unpkg.com/@popperjs/core@2.11.8/dist/umd/popper.min.js"></script>

<!-- 2. Tippy v6 UMD build -->
<script src="https://unpkg.com/tippy.js@6.3.7/dist/tippy.umd.min.js"></script>

<!-- Axios for client-side HTTP requests -->
<script src="https://unpkg.com/axios@1.6.8/dist/axios.min.js"></script>

<!-- 3. Tippy base styles + theme -->
<link rel="stylesheet" href="https://unpkg.com/tippy.js@6.3.7/dist/tippy.css">
<link rel="stylesheet" href="https://unpkg.com/tippy.js@6.3.7/themes/light.css">

<!-- 4. CSS -->
<link rel="stylesheet" href="/resources/node-red-semantic-flow-language/semantic-flow-language.css">

<!-- 5. Plugins that call tippy() -->
<script src="/resources/node-red-semantic-flow-language/node-tooltip.js"></script>
<script src="/resources/node-red-semantic-flow-language/ai-prompt-sidebar.js"></script>

<!-- 6. Plugin registration -->
<script type="text/javascript">
  (function () {
    const customNodeEvents = ['flows:loaded', 'registry:node-set-added', 'registry:node-set-removed']
    const detachFns = []
    let sendTimeout = null

    const removeListener = (eventName, handler) => {
      if (RED?.events?.off) {
        RED.events.off(eventName, handler)
      } else if (RED?.events?.removeListener) {
        RED.events.removeListener(eventName, handler)
      }
    }

    // npm/unpkg lookup helpers (best-effort, cached)
    const npmRegistryUrl = 'https://registry.npmjs.org/'
    const unpkgUrl = 'https://unpkg.com/'

    const sendCustomNodes = async () => {
      const registry = RED?.nodes?.registry

      if (!registry || typeof registry.getNodeList !== 'function') {
        return
      }

      const nodeList = registry.getNodeList() || []
      const nodes = []
      const seenTypes = new Set()

      for (let i = 0; i < nodeList.length; i += 1) {
        const nodeSet = nodeList[i]

        if (!nodeSet || typeof nodeSet.id !== 'string' || nodeSet.id.startsWith('node-red/')) {
          continue
        }

        const types = nodeSet.types || []

        for (let j = 0; j < types.length; j += 1) {
          const type = types[j]

          if (!type || seenTypes.has(type)) {
            continue
          }

          seenTypes.add(type)

          const def = typeof RED?.nodes?.getType === 'function' ? RED.nodes.getType(type) : null

          if (def && def.category === 'config') {
            continue
          }

          const schema = (def && (def.schema || def.defaults)) || {}
          const packageName = (nodeSet && nodeSet.id ? nodeSet.id : type).split('/')[0]

          nodes.push({ name: type, schema, packageName })
        }
      }

      const adminRoot = (RED?.settings?.httpAdminRoot || '').replace(/\/$/, '')
      const url = adminRoot ? `${adminRoot}/ai/custom-nodes` : '/ai/custom-nodes'

      try {
        await axios.post(url, { nodes })
      } catch (err) {
        // Best-effort; no UI impact
        console.warn('[semantic-flow-language] Failed to send custom nodes', err)
      }
    }

    const scheduleSend = () => {
      if (sendTimeout) {
        return
      }

      sendTimeout = setTimeout(() => {
        sendTimeout = null
        sendCustomNodes()
      }, 25)
    }

    const registerListeners = () => {
      if (!RED?.events?.on) {
        return
      }

      for (let i = 0; i < customNodeEvents.length; i += 1) {
        const evt = customNodeEvents[i]

        RED.events.on(evt, scheduleSend)
        detachFns.push(() => removeListener(evt, scheduleSend))
      }
    }

    const unregisterListeners = () => {
      if (!detachFns.length) {
        return
      }

      while (detachFns.length) {
        const detach = detachFns.pop()
        detach()
      }
    }

    RED.plugins.registerPlugin('node-red-semantic-flow-language', {
      type: 'semantic-flow-language',
      onadd() {
        console.log('[semantic-flow-language] Plugin loaded')
        registerListeners()
        scheduleSend()
      },
      onremove() {
        unregisterListeners()
      }
    })
  }())
</script>
